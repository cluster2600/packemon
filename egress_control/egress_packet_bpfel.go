// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64

package egress_control

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

// loadEgress_packet returns the embedded CollectionSpec for egress_packet.
func loadEgress_packet() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_Egress_packetBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load egress_packet: %w", err)
	}

	return spec, err
}

// loadEgress_packetObjects loads egress_packet and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*egress_packetObjects
//	*egress_packetPrograms
//	*egress_packetMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadEgress_packetObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadEgress_packet()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// egress_packetSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type egress_packetSpecs struct {
	egress_packetProgramSpecs
	egress_packetMapSpecs
	egress_packetVariableSpecs
}

// egress_packetProgramSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type egress_packetProgramSpecs struct {
	ControlEgress  *ebpf.ProgramSpec `ebpf:"control_egress"`
	ControlIngress *ebpf.ProgramSpec `ebpf:"control_ingress"`
}

// egress_packetMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type egress_packetMapSpecs struct {
	ArpPktCount     *ebpf.MapSpec `ebpf:"arp_pkt_count"`
	PktEgressCount  *ebpf.MapSpec `ebpf:"pkt_egress_count"`
	PktIngressCount *ebpf.MapSpec `ebpf:"pkt_ingress_count"`
}

// egress_packetVariableSpecs contains global variables before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type egress_packetVariableSpecs struct {
}

// egress_packetObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadEgress_packetObjects or ebpf.CollectionSpec.LoadAndAssign.
type egress_packetObjects struct {
	egress_packetPrograms
	egress_packetMaps
	egress_packetVariables
}

func (o *egress_packetObjects) Close() error {
	return _Egress_packetClose(
		&o.egress_packetPrograms,
		&o.egress_packetMaps,
	)
}

// egress_packetMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadEgress_packetObjects or ebpf.CollectionSpec.LoadAndAssign.
type egress_packetMaps struct {
	ArpPktCount     *ebpf.Map `ebpf:"arp_pkt_count"`
	PktEgressCount  *ebpf.Map `ebpf:"pkt_egress_count"`
	PktIngressCount *ebpf.Map `ebpf:"pkt_ingress_count"`
}

func (m *egress_packetMaps) Close() error {
	return _Egress_packetClose(
		m.ArpPktCount,
		m.PktEgressCount,
		m.PktIngressCount,
	)
}

// egress_packetVariables contains all global variables after they have been loaded into the kernel.
//
// It can be passed to loadEgress_packetObjects or ebpf.CollectionSpec.LoadAndAssign.
type egress_packetVariables struct {
}

// egress_packetPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadEgress_packetObjects or ebpf.CollectionSpec.LoadAndAssign.
type egress_packetPrograms struct {
	ControlEgress  *ebpf.Program `ebpf:"control_egress"`
	ControlIngress *ebpf.Program `ebpf:"control_ingress"`
}

func (p *egress_packetPrograms) Close() error {
	return _Egress_packetClose(
		p.ControlEgress,
		p.ControlIngress,
	)
}

func _Egress_packetClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed egress_packet_bpfel.o
var _Egress_packetBytes []byte
